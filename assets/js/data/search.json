[ { "title": "2022 ICPC 후기 (본선, 예선)", "url": "/posts/ICPC-%EC%98%88%EC%84%A0-%ED%9B%84%EA%B8%B0/", "categories": "알고리즘", "tags": "알고리즘, 국민대학교, ICPC", "date": "2022-11-23 00:00:00 +0900", "snippet": "개요2번째이자 마지막 ICPC에 참가했다.학교 PS 동아리(KPSC)에서 팀을 구했고, 몇 달동안 매주 팀 연습을 진행하는 식으로 준비했다.예선예선 결과국민대 1등, 전체 33등을 했다.(2등 팀은 원래 잘 해서 매번 본선 진출하던 팀이고 3등 팀은 솔브드 마스터인 신입생이 있는 팀이었다.)3등까지 모두 6솔이지만 우리 팀은 꽤 큰 패널티 차이로 1등을 했다.앵간한 문제를 보자마자 뚝딱 풀어버리는 팀원 ktw가 일단 너무 잘 했고, 평소에 코포 앳코더를 되게 열심히하는 herdson형이 최근에 앳코더에서 얻어맞고 업솔빙한 유형이었던 G를 아주 빠르게 푼 것도 컸다.그리고 팀연습이 패널티를 줄이는 것에 도움이 된 것 같다. 팀 연습을 하면서 나눠서 해석을 하고 이해가 된 걸 풀 수 있을 것 같은 사람에게 바로 설명해준 뒤 짤 수 있는 경우에 바로 짜는 식의 전략이 생겼는데 예선에서 잘 먹혔다.예선 후기대회장에서 나와서 여러 가지 기분이 들었다.먼저, 팀원들을 보고 대단하다고 생각했다. 거의 매주 코포나 앳코더를 참가하면서 매번 업솔빙을 하는 팀원은 평소에도 굉장하다고 생각했는데 실전에서 업솔빙의 결과가 딱 나왔고, 원래도 정말 잘 하지만 UCPC를 치러본 이후로 업솔빙과 다양한 유형 문제 풀어보기 위주로 방향을 바꾸고 매 팀연습마다 점점 더 느는게 눈에 보이는 팀원도 있었다.그런 점에서 아쉽기도 하다. PS를 똑바로 시작한 지도 얼마 안 됐고 진짜 열심히 공부한 기간은 더 짧은 것 같은데 벌써 마지막 ICPC라는 것과, 팀원들만큼 열심히 하고 잘 하지 못한 게 아쉬웠다.하지만 다른 것보다 너무 기뻤다. 일단 학교 내에서 잘 하는 팀들을 이겨서 1등을 했고, 안정권으로 본선에 진출하게 되어 마지막 ICPC를 더 이어가게 되었다.그 뒤 회식을 하러 갔다.본선지난 예선 이후로 뭔가 느낀 점들이 있었다.일단 팀원들이 성장하는 모습을 보고 동기부여를 받아 좀 더 열심히 하게 되었다.그리고 팀원들이 너무 잘 해줘서, 본선 진출이 원래 목표였지만 더 위를 노려보고 싶었다.예선에서 내가 셋 중 제일 못 했던 것 같아서 본선에서는 더 잘 해보고 싶은 마음도 컸다.그래서 오랜만에 PS가 정말 재미있게 느껴졌고, 중간고사 기간에도 틈틈히 문제를 풀면서 준비했다.본선 결과7솔(DEFIJKL), 전체 24등을 했다.본선 후기개인적으로는 꽤 만족스럽긴 했다. D, F, L의 풀이를 생각했고 L을 짰다.본격적인 대회 준비를 올해 처음 해 보면서 개념과 기초적인 문제 위주로 랭작을 하던 기존 방식에서 벗어나서 활용 위주의 문제들을 많이 풀어보고 업솔빙을 틈틈히 해서 실력이 꽤 는 것이 느껴졌다. (원래의 내가 너무 못하던 것 같다. PS가 아니라 알고리즘 공부 정도만 했던 것 같다.)하지만 조금 아쉽기도 했다. 초반에 생각보다 구현에서 시간을 많이 잡아먹었기도 했고, 마지막으로 풀던 C도 풀이는 거의 다 잡은 것 같았는데 구현에서 문제가 생기고 시간이 모자라 아깝게 못 풀었다. (그 문제만 풀었다면 입상이었다..)분명히 원래는 꿈도 못 꿨을 성적이고, 국민대에서 지금까지 이 정도 등수가 나온 적이 없었던 걸로 알아서 이미 충분히 기분이 좋지만, 이게 내 마지막 ICPC라서 참 아쉬운 것 같다. 이제야 조금 길이 보이는데 다음 기회는 이제 없다..마치며좋은 팀원들을 만날 수 있어서 정말 감사했다. 어떻게 공부해야 하는지 많이 배웠다. 그리고 너무 잘 풀어줬다.그리고 국민대 PS의 미래가 밝다. 우리 팀 ktw와 다른 팀 그 후배(마스터)의 내년 ICPC가 기대된다. ㅋㅋㅋ난 이제 배치만 치고 거의 방치해둔 코포, 앳코더나 열심히 해야겠다. 종강하면 바로 코포 블루부터 목표로 달릴 거다." }, { "title": "DMLab 알고리즘 스터디 12주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-12%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-11-23 00:00:00 +0900", "snippet": "개요12주차 스터디는 DFS 관련 문제들을 풀었다.A번2644문제 요약부모자식 관계들이 주어졌을 때, 두 사람의 촌수를 출력하는 문제다.설명그냥 DFS로 풀 수 있다.B번17472문제 요약복잡해서 생략. 직접 눌러서 보자.설명 DFS로 섬들마다 ID들을 만들어준다. 섬의 개수를 N이라 하면, N*N으로 섬들을 연결하는 간선들을 만들어준다. MST를 만든다. 나는 크루스칼(UF)를 썼다.굉장히 귀찮았다.C번11123문제 요약위 문제에서 섬의 개수를 출력하는 것이랑 같다고 생각하면 된다.설명그냥 DFS로 풀 수 있다.D번17265문제 요약그리드에 수와 사칙연산이 적혀있을 때 오른쪽과 아래로 이동이 가능하다.가장 오른쪽 아래로 갔을 떄 최대값과 최소값을 출력하는 문제다.설명N이 너무 작아서 아마도 BF로도 풀릴 것이다. (아마 BF로 BFS를 하는 게 정해인 것 같다.)나는 DP로 풀었다.후기ICPC가 끝나고 본격적인 PS는 잠시 휴식중인데, 오랜만에 간단한 문제들을 푸는것도 나름 재미있었다." }, { "title": "DMLab 알고리즘 스터디 11주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-11%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-11-16 00:00:00 +0900", "snippet": "개요11주차 스터디는 주제는 특별히 없고, 재밌게 풀 수 있을 것 같은 문제를 골랐다.A번5525문제 요약 P1: IOI P2: IOIOI P3: IOIOIOI위와 같은 형태의 문자열을 PN이라고 하자.문자열과 N이 주어졌을 때, 문자열 안에 PN이 몇 군데 있는지 구하는 문제다.설명이 문제의 핵심 아이디어는 N&lt;=M인 PM을 찾는다면 그 PM 안에는 M-N+1개의 PN이 있다는 것이다.즉 IOIOIOI라면 IOI가 3개 있는 것이다.그래서 지속적으로 현재 몇개의 연속 IOI를 마주쳤는지를 세 주면서, 끊길 때 세 주면 된다.B번5052문제 요약전화번호의 목록이 주어졌을 때, 이 목록이 일관성이 있는지 구하는 문제이다.일관성은 한 번호가 다른 번호의 접두어인 경우가 없어야 하는 것이다.설명이 문제는 트라이 기초 문제로 볼 수도 있는데 정렬로 더 쉽게 풀 수 있다.문자열 정렬이 어떻게 동작하는지만 잘 알고 있다면 정렬해서 바로 다음 문자열이 현재 문자열의 접두어인지만 확인하면 된다는 것을 이해할 수 있을 것이다.C번1600문제 요약장애물이 있는 그리드에서, 상하좌우 인접 칸으로 움직이거나 최대 K번 나이트처럼 움직여서 (0,0)에서 (H-1,W-1)로 가는 최소 이동 횟수를 구하는 문제다.설명단순히 BFS로 풀 수 있는 문제이다.나이트처럼 움직일 수 있는 횟수 K번을 Z축으로 잡고, 3차원에서 BFS를 돌린다고 생각하면 된다.단 Z축은 아래로만 움직일 수 있을 것이다. (횟수는 감소해야 하니까)D번2263문제 요약이진 트리의 후위 순회와 중위 순회가 주어졌을 때, 전위 순회를 구하는 문제다.설명이 문제는 트리의 순회를 잘 알고 있다면 재밌게 풀 수 있는 문제다.첫 번째로, 인오더는 결국 노드의 순서를 나타내고 있다. 따라서 키가 정렬된 트리가 주어졌을 때 포스트오더를 동해 트리를 만드는 문제로 환원시킬 수 있다. BST라고 생각하자.두 번째로, 포스트오더의 마지막은 항상 루트다. 그럼 루트를 제거하고 서브트리는 어떻게 나눌 수 있을까?키가 정렬되어 있기 때문에 키가 더 작으면 왼쪽, 키가 더 크면 오른쪽으로 보낼 수 있고, 또한 두 그룹은 각각 인접할 것이다. 따라서 구간 (s, e)가 주어지면 e가 루트고, 키를 기준으로 나눌 수 있는 점 m을 찾아 (s, m-1)과 (m, e-1)로 나누면 된다.이제 각 서브트리를 분할 정복한다고 생각하고 재귀로 풀면 끝이다.후기재밌었다. 내가 재밌어 보이는걸 골랐으니 당연한가?" }, { "title": "DMLab 알고리즘 스터디 10주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-10%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-11-09 00:00:00 +0900", "snippet": "개요10주차 스터디는 프로그래머스에서 풀기로 했다.A번: 기능개발문제 요약순서가 중요한 작업들의 진행 상황이 주어졌을 때, 한 번의 배포에 몇 개씩 묶어서 배포할 수 있는지 구하기설명대충 나머지를 이용해 몇일 걸리는지 다 구해놓고,그 다음에는 마지막으로 배포된 녀석을 저장하면서 그보다 뒤에 있으면서 먼저 마무리되는 작업을 묶어준다.B번: 네트워크문제 요약컴퓨터 간의 연결이 인접 행렬로 주어졌을 때, 네트워크의 개수를 구하는 문제설명dfs로 풀수 있는 문제지만 더 깔끔하게 풀고 싶어서 union-find로 풀었다.C번: 야근 지수문제 요약남을 일의 작업량들이 주어졌을 때, 야근 지수를 최소화하는 방법이때 야근 지수는 남은 일의 작업량을 제곱한 값의 합이다.n만큼 일을 할 수 있고, 일을 할 때마다 작업량이 1씩 줄어든다.설명n이 작아서 그냥 pq로 최댓값을 계속 찾아 1씩 빼도 된다.D번: 크레인 인형뽑기 게임문제 요약크레인을 이용해 인형을 뽑아 바구니에 넣는 게임이 있다.바구니에 같은 2개를 인접하게 넣으면 사라진다.행동의 목록이 주어질 때 시뮬레이션 해서 사라진 인형의 개수를 구하기설명그냥 스택을 이용해 시뮬레이션하면 풀린다.후기문제가 대부분 구현 위주여서 쉽게 풀었다.다음주에는 백준으로 돌아갈 예정이다." }, { "title": "DMLab 알고리즘 스터디 9주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-9%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-11-03 00:00:00 +0900", "snippet": "개요9주차 스터디는 dp 관련 4문제였다.A번14494문제 요약오른쪽, 아래, 오른쪽 아래 대각선으로만 이동해서 (1, 1)부터 (n, m)으로 이동하는 경우의 수 구하기설명dp[y][x] = dp[y-1][x] + dp[y][x-1] + dp[y-1][x-1]B번10164문제 요약격자에서 (1, 1)부터 (n, m)으로 이동하는데, k번째 칸을 반드시 지나야 한다. 이때 이동하는 경우의 수 구하기설명dp[y][x] = dp[y-1][x] + dp[y][x-1]저걸 두번 계산해 곱해주면 된다.C번5582문제 요약두 문자열에서 연속 부분 문자열이 겹치는 최대 길이 구하기설명A[y]와 B[x]의 문자가 같을 때,dp[y][x] = dp[y-1][x-1] + 1그 과정에서 최댓값을 구하면 된다.D번1086문제 요약집합의 순열 중 K로 나누어 떨어지는 수의 개수 구하기설명풀지 못했다.후기한 문제를 못 풀어서 아쉬웠다. 다음에 업솔빙 해야겠다." }, { "title": "DMLab 알고리즘 스터디 8주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-8%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-10-04 00:00:00 +0900", "snippet": "개요8주차 스터디는 그리디 관련 4문제였다.A번11501문제 요약주가가 변동하는데, 매일 주식을 하나씩 살 수 있고 원하는 만큼 팔 수 있다.주가를 다 미리 알고 있을 때 최대 이익을 내는 문제설명각 주식마다 그 이후에 나오는 최대까지 들고 있다가 팔면 끝이라서 각 지점에서의 최댓값을 구해놓으면 된다.prefix sum처럼, 뒤에서 보는 max를 구하면 된다. (postfix max라고 하면 되는거 같다.)그럼 그냥 O(N)으로 훑으면서 마주치는 주식마다 그 이후 최댓값에 바로 팔면 끝B번2812문제 요약N자리 수에서 K개를 지워서 얻을 수 있는 가장 큰 수 구하기설명스택을 통해서 A[i]보다 A[i+1]가 큰 경우를 앞에서부터 반복적으로 지워준다.(스택을 쓰는 이유는 A[i]를 지웠더니 A[i-1]과 A[i+1]의 값도 지워야 하게 될 수 있기 때문이다.)그 후, 남은 K는 남은 수들 중 가장 작은 것들을 없애면 된다.어쩌다 풀긴 했는데 왜 맞는지는 잘 모르겠다.Proof by ACC번12904문제 요약문자열 S, T가 있다.S에 2가지 연산을 마음대로 적용시켜서 T를 만들 수 있는지 구하기 S 뒤에 A를 붙이는 연산 S를 뒤집고 뒤에 B를 붙이는 연산설명T를 보면서, 그냥 끝이 A면 A를 빼고 끝이 B면 B를 빼고 뒤집어주는 식으로 반복해서 S가 나오는지 보면 끝이다.D번1132문제 요약두 수를 더했을 때 최대가 되도록 알파벳에 숫자를 배정하는 문제설명자릿수를 보고, 저 A가 100의 자리라면 100A라고 생각하면 된다.그런식으로 알파벳마다 실제 값은 몇 배인지 확인해주자. 그 후 정렬해서 가장 큰 값부터 9부터 차례대로 배정해주면 된다.그리고 한가지 더 생각해줘야 하는 부분이, 0이 앞에 오는 경우는 없다는 것이다.그래서 0이 될 수 없는 수들은 따로 체크를 해 주고, 0이 될 수 있는 수 중 가장 작은 수를 대신 0으로 정해주면 된다.후기이번 주는 뭔가 의욕이 없었는데 그리디라서 재밌게 풀 수 있었다." }, { "title": "PS용 세팅 정리", "url": "/posts/PS%EC%9A%A9-%EC%84%B8%ED%8C%85-%EC%A0%95%EB%A6%AC/", "categories": "알고리즘", "tags": "알고리즘, 백준, 환경, PS", "date": "2022-09-28 00:00:00 +0900", "snippet": "개요거의 고정으로 사용하는 편한 PS용 세팅이 있는데, 주변에 알려줄 일이 좀 있기도 하고 헷갈릴때 보려고 정리해 뒀다.VSCode를 사용하는 것을 기준으로 한다.CPH와 Competitive Companion을 통한 테스트케이스 자동 파싱먼저 VSCode 확장에서 Competitive programming helper (cph) 확장을 설치한다.이 확장은 문제에 테스트케이스를 정리하고 실행시켜 주는 역할을 한다.추가적으로 브라우저에 Competitive Companion 확장을 설치해서 자동으로 테스트케이스를 가져올 수 있도록 한다.크롬 웹스토어파이어폭스 웹스토어이 확장을 설치하고 백준, 코드포스 등의 문제 페이지에서 오른쪽 위 확장 프로그램 쪽에 있는 +버튼을 누르면, vscode에서 문제 파일이 생성되며 테스트케이스들을 파싱해 넣어준다.그럼 VSCode에서는 이렇게 된다. 여기서부터는 사용법을 쉽게 알 수 있을 것이다.(추가적으로 모든 테케 실행 단축키 세팅을 해 두면 좋다. 아래에서 설명)Code runner를 통한 빠른 컴파일 및 실행디버그, 확인 등을 이유로 CPH 대신 터미널에서 실행시키고 싶을 때가 있다.그 때는 Code runner를 사용하는데, 단축키 한 번으로 터미널에서 실행이 가능한 확장이다.이런 확장이다.실행 명령어나 옵션도 다 설정이 가능하고 언어별로도 다 지원을 한다.그런데 우리는 위 사진과는 다르게 터미널에서 실행을 할 것이기 때문에 설정을 하나 바꿔줘야 한다.VSCode 좌측 확장 탭 -&gt; Code runner의 설정 버튼 -&gt; 확장 설정 -&gt; Run in terminal 옵션을 true로 바꿔준다.그럼 터미널에서 실행하게 되어 수동으로 테케를 넣어볼 수 있다.단축키 설정맥이라면 command + shift + p, 아니라면 ctrl + shift + p를 누르면 명령어 팔레트를 열 수 있다.거기서 Preferences: Open Keyboard Shortcuts를 검색해 선택하면 단축키 설정이 열린다. 입맛에 맞게 바꿔주자.나는 command + r: Run Code, command + t: Run Testcases로 설정해 위 두 확장을 사용하고 있다.(겹치는 명령어가 있다고 뜨긴 하지만 그냥 무시해도 체감상 불편함이 없었다.)" }, { "title": "DMLab 알고리즘 스터디 7주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-7%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-09-28 00:00:00 +0900", "snippet": "개요7주차 스터디는 수학 관련 4문제였다.(이번 주부터 못 풀더라도 꼭 문제를 파악하게 오는 것으로 바뀌어서 4문제가 되었다.)A번2089문제 요약어떤 수 N이 주어졌을 때, -2진수로 나타내기설명케이스 워크로 풀었는데, 생각해보니 -2진수는 2진수와 같은 원리로 풀 수 있었다. 그 풀이는 영문 위키피디아로 대체내가 생각한 풀이는 아래와 같다.1~1(1개)은 1비트, 2~5(4개)는 3비트, 6~21(16개)는 5비트마찬가지로, -1~-2(2개)는 2비트, -3~-10(8개)는 4비트, -11~-42(32개)는 6비트이런 식으로 정리가 가능해서, N이 주어졌을 때 log N으로 몇 비트에 들어가는 지를 구할 수 있다.이제 저걸 반복적으로 적용해서, -2진수의 큰 비트부터 한 비트씩 보면서 값을 넣을 수 있으면 넣는다. 남은 값이 양수이고 내 비트가 양수라면 넣고, 남은 값이 음수이고 내 비트가 음수라면 넣는 식이다. (알맞은 1을 넣기 위한 부분) 반례를 해결하기 위해, 남은 값이 총 몇 비트로 표현이 가능한지 확인해서 다음 비트로 이동한다. 예를 들어 9(11001)에서 11까지 채운 후 3비트가 남았는데, 지금까지 8을 채워서 남은 값이 1이므로 1은 1비트로 표현이 가능한 것을 위 방법대로 구한다. 그러면 0을 두 번 채우면서 비트를 이동시키면 된다. (알맞은 0을 넣기 위한 부분)뭔가 직관에 의존해서 풀어서 설명하기가 힘들다. 그리고 정해가 따로 있는데 괜히 더 어렵게 푼 것 같다.B번1111문제 요약ARR[i+1] = A * ARR[i] + B의 형태로 표현되는 수열을 줄 때, 다음 수열 값을 구하는 문제설명브루트포스로도 예외적인 경우를 다 잘 고려해준다면 풀 수 있겠지만, 그렇게 풀기 싫어서 생각을 더 해 봤다.그랬더니 초등학생 때 본 것 같은 느낌으로, 수열 -&gt; 수열의 차이들 -&gt; 수열의 차이들의 배율 이런 식으로 계산할 수 있다.그런데 좀 케이스 워크를 해 줘야 하는 부분이 있어서 약간 귀찮았다.C번20500문제 요약1과 5로만 구성된 N자리 수 중 15의 배수의 개수를 구하는 문제설명15 = 3 * 5라서, 3의 배수이면서 5의 배수인 수를 세 주면 된다.5의 배수는 0이나 5로 끝나기 때문에, 이 문제의 경우에는 5로 끝나는지만 파악하면 된다.3의 배수는 각 자릿수를 모두 더했을 때 3의 배수인지를 확인해 주면 된다. 1의 개수를 1~N-1으로 반복을 한다. 5의 개수는 N-(1의 개수)다. 15의 배수인지를 위 방법대로 파악을 한다. 아니라면 넘어간다. 그 중 마지막자리에 가야 하는 5 하나를 제외하고, 1과 5를 섞어서 나올 수 있는 모든 경우의 수를 구한다. (모듈러 역원을 이용해서 팩토리얼 조합으로 계산)D번1328문제 요약높이가 모두 다른 빌딩 N개가 있을 때, 왼쪽에서 L개 오른쪽에서 R개가 보이는 경우의 수 구하기설명그냥 확통으로 풀 수 있을 줄 알았는데 생각보다 복잡하기도 하고, 시간을 이번주에 많이 투자를 못 해서 못 풀었다.후기한 문제를 못 푼게 아쉬웠고, 그리고 문제를 내가 골랐는데 생각보다 재미없는 문제도 껴 있어서 아쉬웠다." }, { "title": "DMLab 알고리즘 스터디 6주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-6%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-09-21 00:00:00 +0900", "snippet": "개요6주차 스터디는 정렬 관련 6문제였다.A번9237문제 요약묘목을 심는데 1일, 자라는데 T_i일이 걸린다.묘목을 모두 심어서 다 자라게 하는 최소 일수 구하기설명정렬해서 오래 걸리는 것부터 심으면 된다.B번18310문제 요약일직선 위에 집들의 위치가 주어질 때, 안테나를 설치해 집들과의 거리의 총합을 최소화하려면안테나를 어디 설치해야 하는지 구하는 문제설명안테나가 어떤 집보다 오른쪽에 있다면, 오른쪽으로 갈때마다 그 집과의 비용이 1씩 증가한다. 왼쪽도 마찬가지.그래서 좌우에 있는 집의 수를 같게 해 주면 된다.이해가 잘 안 간다면, 아래와 같이 생각하면 된다. 왼쪽 집의 수를 L이라 하고, 오른쪽 집의 수를 R이라 하자. L &lt; R이라면 무조건 오른쪽으로 옮기는게 이득이다. (1칸 오른쪽으로 옮길 때마다 왼쪽 집들의 비용은 L만큼 증가, 오른쪽 집들의 비용은 R만큼 감소) 그 반대도 같으므로, L == R인 어느 지점이 최소라고 할 수 있다. (집의 개수가 홀수라면 1 차이가 나는데 상관 없다.)따라서 중간값을 구해서 출력하면 끝이다.C번17140문제 요약그냥 구현 문제설명많이 귀찮은 구현 문제다. 설명 생략D번2212문제 요약고속도로 위에 N개의 센서가 있는데, 집중국과 통신이 가능해야 한다. 집중국은 최대 K개 설치가 가능하다.집중국의 통신 가능 영역은 구간으로 표현된다. 구간 길이의 총합을 최소화하는 문제다.다르게 설명하면, K개의 구간으로 N개의 점을 덮으면서 구간의 길이를 최소화하는 문제다.설명점들 간의 모든 구간(N-1개)을 구한다. 그 뒤 정렬해 가장 큰 K-1개의 구간들을 없애면 끝이다.E번1092문제 요약크레인들과 짐들이 있다. 크레인은 매 초 하나의 짐을 옮길 수 있다.짐들의 무게와, 크레인마다의 옮길 수 있는 최대 무게가 주어질 때짐을 다 옮길 수 있는 최소 시간을 구하는 문제설명그리디하게, 매 초 가장 센 크레인부터 각각 실을 수 있는 가장 무거운 상자를 실으면 된다.가장 무거운 상자를 고르는 것은 multiset에서 lower bound로 찾았다.F번16496문제 요약음이 아닌 수들의 수열이 주어졌을 때, 배열해서 만들 수 있는 가장 큰 수를 출력하기설명정렬 기준을 어떻게 잘 만들면 되지 않을까 하는 아이디어를 떠올릴 수 있을 것이다.가장 먼저 생각해볼 만한 접근은 가장 높은 자릿수부터 비교하는 것이다.그런데 이렇게 했을 때는 자릿수가 다를 때 문제가 생긴다.예를 들어, [1, 10, 102]에서는 1 102 10이고, [1, 10, 100]일 때는 1 10 100이다.그래서 자릿수를 근본적으로 다르지 않게 하는 것이 해결책이다.따라서 약간의 그리디한 아이디어로, int(str(A)+str(B)) &gt; int(str(B)+str(A))라면 A를 앞으로 보내는 방법으로 정렬하면 된다. (자릿수가 다를 수가 없다.)꽤 참신하고 재밌는 문제였다." }, { "title": "DMLab 알고리즘 스터디 5주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-5%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-09-14 00:00:00 +0900", "snippet": "개요5주차 스터디는 누적합 관련 6문제였다.A번13900문제 요약N개의 정수 중, 모든 서로 다른 위치의 수의 곱들의 합을 구하는 문제설명모든 수들의 합을 미리 구해 놓고, (모든 수의 합 - A[i]) * A[i]를 모든 i에 대해 해주면 된다.B번14465문제 요약직선 위에 신호등이 1간격으로 쭉 있었는데, 그 중 몇 개가 고장났다.최소 몇 개의 신호등을 수리해야 연속한 K개의 신호등이 존재하게 할 수 있는지를 구하는 문제설명부서진 신호등들과 가상의 양 끝점들을 점으로 잡고 생각한다.투 포인터로 접근해서 각 점들을 포인터 i와 j로 움직인다고 하자. i와 j 사이에는 항상 K개 이상의 신호등이 존재하면서 최소로 떨어지도록 움직인다.그럼 현재 두 포인터가 몇 개의 부서진 신호등을 사이에 두는지를 지속적으로 보면서 최소값을 갱신해주면 그게 답이다.C번2118문제 요약원형으로 점들이 연결되어 있고, 엣지들마다 거리가 주어진다.그 중 두 점을 골라 만들 수 있는 거리의 최댓값을 구하면 된다.설명꽤 참신한 문제인 것 같았다.원 위에서의 거리는 min(시계방향 거리, 반시계방향 거리)로 구해지는 것을 누적합으로 이용해서,시계 방향: 누적합으로 i~j반시계 방향: 한바퀴 전체 거리 - 누적합으로 i~j이런 식으로 구하면 된다.최대값을 구하는 것은 B번 문제와 마찬가지로 투 포인터로 구했다.D번14476문제 요약N개의 수가 주어졌을 때 정수 하나를 빼서, 나머지 수의 최대공약수가 K의 약수가 아닌 수가 되게 만드는 방법을 구하는 문제설명아이디어를 떠올리기가 좀 어려웠다.왼쪽부터의 gcd, 오른쪽부터의 gcd를 구해 놓고각 i들에 대해 i를 뺀 값을 gcd(left_gcd[1, i-1], right_gcd[i+1, N])로 구하면 된다.E번21757문제 요약정수 수열을 4개의 구간으로 나눠서, 각 구간의 합이 같게 만드는 방법의 수를 구하기설명SCPC 예선에서 풀었던 문제의 쉬운 버전이었다.그런데 SCPC 예선때 짠 코드가 더럽고 이상해서, (억지로 푼 느낌이어서) 다른 사람 풀이를 봤더니 훨씬 깔끔한 풀이가 있었다.일단 처음에 푼 방법은, (전체 누적합 / 4)로 나누어떨어지는 위치들과 몫을 구해 놓는다. (안 나눠 떨어진다면 0) 그럼 [1, 1, -1, 1, 1, 1, 1, 1]는 누적합이 [1, 2, 1, 2, 3, 4, 5, 6] 2로 나눠서, [0, 1, 0, 1, 0, 2, 0, 3]처럼 되고,1중 하나와 2중 하나, 3(항상 마지막이어야 함)을 순서대로 구하는 방법을 구하는 확통으로 접근했다.근데 문제는, [1, -1, 1, -1, 1, -1, 1, -1]같이 0으로 나눠야 하는 경우는 순서가 없어져서 따로 처리를 해 줘야 했다는 건데,SCPC때는 급해서 아예 다른 방법으로, 0을 만드는 모든 위치를 이항 계수로 nCr을 구하도록 처리했다.새롭게 알게 된 풀이는 저렇게 나눠 놓는 게 아니라, i까지의 누적합이 (전체 누적합 / 4) * j 와 같은지를 스위핑과 DP로 세 주는 방법이다.정말 깔끔하게 풀려서 놀랐다.DP는 0, 1, 2, 3 이렇게 4칸만 만들어 두고, 각 i에 대해서 몫이 j라면 dp[j]에 dp[j-1]을 더해주면 된다. (LIS처럼)그 부분의 코드는 아래와 같다.vector&lt;ll&gt; ans(4);ans[0] = 1;for (int i=1; i&lt;N; i++) { for (int j=3; j&gt;=1; j--) { if (presum[i] == bucket_val * j) { ans[j] += ans[j-1]; } }}cout&lt;&lt;ans[3]&lt;&lt;endl;F번1866문제 요약직선 위에 점들이 있다.트럭으로 옮기면 (트럭비용 * 개수 * 거리) 만큼의 비용이 발생하고,헬리콥터로 옮기면 (헬리콥터 비용) 만 발생한다. (개수와 거리에 상관이 없다.)화물의 목적지의 목록이 주어졌을 때, 모든 화물을 옮기는 최소 비용을 구하는 문제설명그리디나 DP로 풀어야 하는 것 같은데 뭔가 아이디어도 생각이 안 나고 풀 의욕도 별로 안 생겼다. 그래서 못 풀었다.다음에 시간 날 때 업솔빙 해 봐야겠다.6주차 문제를 풀다가, 18310 이 문제의 아이디어에서 힌트를 얻어서 다시 도전해 봤다.중간값이라는 아이디어를 생각하면서 접근했는데도 꽤 어려웠다. (내가 DP에 약한 것 같다.)이 문제에서는 물품의 목표 지점들 외의 점은 필요가 없다.(거리가 단순 절댓값이므로, 헬리콥터는 목표 지점 중에서만 골라 보내도 항상 최적값이 나오는 것이 보장된다. 여러 절대값의 합 그래프 개형을 생각해 보자.)먼저 트럭의 비용을 T, 헬리콥터의 비용을 H, d[i]를 i번 목표 지점이라고 하자DP[i] = i번 택배까지 모두 보낼 때 최소 비용으로 잡고, DP[i] = DP[i-1] + d[i] * T로 트럭 비용은 계산할 수 있다.그 다음은 헬리콥터의 비용인데, 헬리콥터는 각각 특정 구간을 맡는다고 생각하면 된다.(i &lt; j &lt; k 일 때, i와 k만 같은 헬리콥터로 보내는 경우는 없다고 생각해도 된다는 말이다.)그럼 이제 구간의 비용도 DP로 계산해 주면 되는데, 각 점마다 이전의 모든 점을 보면서, 두 점 사이의 구간을 확인해 주면 된다. (N^2)그림을 보자. 위에서 말한 두 점(lo, hi)으로 표현되는 구간 하나를 나타낸 것이다.이제 각 구간의 비용을 계산해야 하는데, [lo, hi]의 모든 점에 대헤 dist(mid, point)의 합을 O(1)에 구할 것이다. (위 그림의 빨간 부분)위 그림을 보면서 생각해 볼 수 있는 것은 첫 번째로, [lo, mid]에서 끝나는 선분들은 모두 [0, lo]까지의 길이를 공유하고, [mid, hi]에서 끝나는 선분들은 [0, mid]를 공유한다는 것이다.두 번째는 [lo, mid]에서 끝나는 선분들과 [mid, hi]에서 끝나는 선분들만 보면 된다는 것이다.그래서, 각 점들을 통해 누적합을 만들어서, 특정 구간에서 끝나는 선분들의 길이의 합을 빠르게 구할 수 있게 한다.[lo, mid]에서 끝나는 선분의 빨간 부분은 각각 보면 [0, mid] - 파란 선분이다. 따라서 모든 선분이 공유하는 부분 [0, mid]는 d[mid] * [lo, mid]에서 끝나는 선분의 수로 계산해 줄 수 있고, 서로 다른 부분(파란색)은 누적합으로 [lo, mid] 사이에서 끝나는 모든 선분의 길이의 합을 구해 빼주면 된다.(d[mid] * (mid - lo + 1) - (presum[mid] - presum[lo-1])) * T[mid, hi]은 좀 더 쉽다. [mid, hi]에서 끝나는 모든 선분들의 길이를 누적합으로 구해서 [0, mid]까지의 공유하는 길이를 모두 빼 주면 된다.((presum[hi] - presum[mid]) - d[mid] * (hi - mid)) * T;그럼 헬리콥터의 비용은 위 두 값 + H로 구할 수 있다. DP[lo-1]에 더해주면 된다.전체 코드는 아래와 같다.#include &lt;bits/stdc++.h&gt;#define fastio cin.tie(0)-&gt;sync_with_stdio(0)#define endl '\\n'#define all(x) x.begin(), x.end()#define sz(x) x.size()using namespace std;typedef long long ll;int main() { fastio; int N; cin&gt;&gt;N; vector&lt;int&gt; d(N+1); vector&lt;int&gt; presum(N+1); vector&lt;int&gt; dp(N+1); for (int i=1; i&lt;=N; i++) cin&gt;&gt;d[i]; int T, H; cin&gt;&gt;T&gt;&gt;H; sort(all(d)); for (int i=1; i&lt;=N; i++) presum[i] = presum[i-1] + d[i]; for (int hi=1; hi&lt;=N; hi++) { dp[hi] = dp[hi-1] + d[hi] * T; for (int lo=hi; lo&gt;=1; lo--) { int mid = (lo+hi)/2; int low_dists = (d[mid] * (mid - lo + 1) - (presum[mid] - presum[lo-1])) * T; int high_dists = ((presum[hi] - presum[mid]) - d[mid] * (hi - mid)) * T; dp[hi] = min(dp[hi], dp[lo-1] + low_dists + high_dists + H); } } cout&lt;&lt;dp[N]&lt;&lt;endl;}" }, { "title": "DMLab 알고리즘 스터디 4주차", "url": "/posts/DMLab-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-4%EC%A3%BC%EC%B0%A8/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-09-01 00:00:00 +0900", "snippet": "개요4주차 스터디는 자료구조 관련 6문제였다.A번1417문제 요약N명의 후보들의 득표수들이 주어지고,1번 후보가 당선되게 하기 위해서 유권자를 몇명이나 매수해야 하는지를 구하는 문제설명Max PQ에 1번을 제외한 후보의 득표수를 넣고,가장 큰 득표수가 1번의 득표수보다 작아질 때까지, 1표를 옮기고 PQ에 집어넣기를 반복하면 된다.꼭 1표씩 처리해줘야 한다.B번2002문제 요약터널을 지나가는 차량 번호의 순서가 주어졌을 때, 터널 내에서 추월한 차를 모두 찾기설명추월한 차의 번호를 관리하는 set을 만들고, 차 번호 배열 in과 out을 비교하면서 다르면 set에 넣는다.이미 set에 들어간 차라면 continue해 준다.C번1253문제 요약문제 제목이 마음에 든다.N개의 수 중 다른 두 수의 합으로 나타낼 수 있는 수의 개수를 구하면 된다.설명map&lt;int, set&lt;int&gt;&gt; where를 만들어서, 어떤 값이 어떤 인덱스들에 있는지를 저장해 둔다.2중 for를 돌면서, 모든 A, B에 대해 A+B가 where 안에 있는지 확인한다.그 후 set에 있는만큼 세 주고, set에서 제거해준다.‘다른’ 두 수가 맞는지, A와 B가 같은 인덱스인지를 신경써주면 된다.D번17398문제 요약그래프에서 엣지를 하나씩 제거하는데, 엣지가 집합을 둘로 나누는 경우에는 두 집합의 크기를 곱한 만큼 비용이 발생한다.비용의 총합을 구하는 문제설명아이디어가 꽤 참신한 문제관찰해보면 UF의 Union를 반대로 진행하고 있다는 것을 확인할 수 있다. (집합을 둘로 분리하기)그래서 쿼리를 역순으로 처리하면서, Union시마다 둘의 size를 곱한 만큼 ans에 더해주면 된다.UF에서 size를 잘 관리해주자.E번16964문제 요약어떤 트리가 있다.어떤 탐색 순서가 주어졌을 때, 트리 위에서 DFS로 가능한 탐색인지 확인하는 문제설명DFS를 잘 시뮬레이션 하면 된다. (스택을 이용해서)다음 노드는 고정되어 있으므로, 그 다음 노드로 가는 방법이 있는지만 확인하면 된다.자식을 먼저 확인하고, 자식 중에 없으면 스택의 이전 노드로 되돌아가서 반복하면 된다.F번13511문제 요약비용이 있는 트리가 주어질 때, 어떤 노드 u, v를 잇는 경로의 비용 어떤 노드 u, v의 경로 중 u로부터 k번째 노드 찾기이렇게 두 가지 쿼리를 처리하는 문제설명LCA로 접근하고, 경로는 u-&gt;LCA + LCA-&gt;v라는 점을 이용하면 된다.1번 쿼리는 u-&gt;LCA의 비용, v-&gt;LCA의 비용을 더해서 출력하면 되고,2번 쿼리는 u-&gt;LCA가 몇 개인지, LCA-&gt;v가 몇 개인지를 생각해보고 어디에 위치하는지 생각해보면 된다.그래서 LCA의 쿼리를 두 가지로 짜면 된다." }, { "title": "LCA (Lowest Common Ancestor) 알고리즘", "url": "/posts/LCA-(Lowest-Common-Ancestor)-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/", "categories": "알고리즘", "tags": "알고리즘, 백준", "date": "2022-08-29 00:00:00 +0900", "snippet": "소개LCA란 트리에서 두 노드의 가장 가까운 공통 조상을 찾는 알고리즘이다.그렇다면 LCA가 필요한 이유는 무엇일까?바로 설명하자면 트리에서 최단 경로를 LCA로 구하기 때문이다.트리에서 두 노드 u, v의 최단 경로는 u-&gt;LCA + LCA-&gt;v 이다. (조금 생각해보면 트리의 성질에 의해 당연하다는 것을 알 수 있다.)예시: 4와 7의 LCA는 2고 최단 경로는 4-2-5-7이다.그럼 LCA를 어떻게 구할 수 있을까?접근첫 번째 방법naive한 접근으로는 두 노드를 만날 때까지 한 단계씩 옮겨주는 방법을 생각해 볼 수 있다. DFS로 트리를 빌드할 때 노드마다 깊이를 기억해 둔다. 두 노드가 같아질 때까지 더 낮은 노드를 끌어올린다.간단하게 코드로 설명하자면 아래와 같을 것이다.const int MAXN = 50001;int depth[MAXN]; // 노드의 깊이int parent[MAXN]; // 노드의 부모int lca (int u, int v) { while (u != v) { if (depth[u] &lt; depth[v]) v = parent[v]; else u = parent[u]; } return u;}이런 방법으로 풀 수 있는 기본 문제가 있으니 시도해보자.11437[expand]summary: 코드 보기#include &lt;bits/stdc++.h&gt;#define fastio cin.tie(0)-&gt;sync_with_stdio(0)#define endl '\\n'using namespace std;typedef long long ll;typedef vector&lt;vector&lt;int&gt;&gt; adj_list;const int MAXN = 50001;int depth[MAXN];int parent[MAXN];void dfs (adj_list&amp; G, int now, int par=-1, int d=0) { parent[now] = par; depth[now] = d; for (int child: G[now]) { if (child != par) dfs(G, child, now, d+1); }}int lca (int u, int v) { while (u != v) { if (depth[u] &lt; depth[v]) v = parent[v]; else u = parent[u]; } return u;}int main() { fastio; int N; cin&gt;&gt;N; adj_list G(N+1); for (int i=0; i&lt;N-1; i++) { int u, v; cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v); G[v].push_back(u); } dfs(G, 1); int M; cin&gt;&gt;M; while (M--) { int u, v; cin&gt;&gt;u&gt;&gt;v; cout&lt;&lt;lca(u, v)&lt;&lt;endl; }}[/expand]두 번째 방법첫 번째 방법의 문제는 무엇일까?시간복잡도가 트리의 깊이에 비례하는 것이다.트리가 잘 균형 잡혀있다면 문제가 없겠지만 위 그림과 같은 극단적인 경우 O(N)에 가까워진다. 따라서 다른 방법의 접근이 필요하다.트리에서 부모를 향해 이동하는 것은 탐색이 아니라 단순히 한 경로만을 타고 올라가는 것이다. 언제 탐색하든 같은 결과를 얻을 수 있다.따라서 우리는 메모리를 써서 DP처럼 이 문제를 다룰 수 있다. cost의 대부분은 높이를 맞춰주는 부분에서 발생한다. (높이가 같아진다면 그때부터 root까지는 최대 log N의 높이를 가지기 때문) 높이를 빠르게 맞추기 위해, 1번 위의 조상, 2번 위의 조상, 4번 위의 조상, 8번 위의 조상, …, 2^n번 위의 조상을 기록해 놓는다. 탐색 시 더 낮은 노드 u에서 높은 노드 v로 끌어올리기 위해, v의 높이 이하이며 최대한 높은 u의 조상으로 이동을 반복한다. 높이가 같아지면 첫 번째 방법과 똑같이, 두 노드가 같아질때까지 둘다 끌어올리면 된다.위 그림을 기준으로 생각해보면 아래와 같이 진행된다. 5의 1번째 조상(4), 2번째 조상(3), 4번째 조상(1) 중 6의 높이 이하인 가장 높은 노드는 2번째 조상(3)이므로 3으로 이동 3의 1번째 조상(2), 2번째 조상(1) 중 6의 높이 이하인 가장 높은 노드는 1번째 조상(2)이므로 2로 이동 높이가 같으므로, 만날 때까지 두 노드를 끌어올리기아래는 LCA 2 문제를 해결한 소스다.참고하며 읽으면 도움이 될 수도 있다.11438[expand]summary: 코드 보기##include &lt;bits/stdc++.h&gt;#define fastio cin.tie(0)-&gt;sync_with_stdio(0)#define endl '\\n'using namespace std;typedef long long ll;typedef vector&lt;vector&lt;int&gt;&gt; adj_list;class LCA { vector&lt;int&gt; depths; vector&lt;vector&lt;int&gt;&gt; ancestors;public: LCA (adj_list&amp; tree, int root) { // 양방향 리스트로부터 LCA 트리 빌드하기 // ancestors[i] = 2^i번째 조상 int N = tree.size(); ancestors = vector&lt;vector&lt;int&gt;&gt;(N); depths = vector&lt;int&gt;(N); queue&lt;int&gt; q; q.push(root); ancestors[root].push_back(root); while (!q.empty()) { int now = q.front(); q.pop(); int depth = depths[now]; for (int i=1, d=2; d&lt;=depth; d&lt;&lt;=1, i++) { ancestors[now].push_back(ancestors[ancestors[now][i-1]][i-1]); } for (int child: tree[now]) { if (ancestors[now][0] == child) continue; ancestors[child].push_back(now); depths[child] = depth+1; q.push(child); } } } int find(int u, int v) { if (depths[u] &lt; depths[v]) swap(u, v); // ancestors를 이용해 끌어올리기 int dv = depths[v]; while (depths[u] &gt; dv) { int diff = depths[u] - dv; int jump = 0, jumpd = 1; while (jumpd&lt;&lt;1 &lt;= diff) jumpd&lt;&lt;=1, jump++; u = ancestors[u][jump]; } while (u != v) { int jump; for (jump=1; jump&lt;ancestors[u].size() &amp;&amp; ancestors[u][jump]!=ancestors[v][jump]; jump++); u = ancestors[u][jump-1]; v = ancestors[v][jump-1]; } return u; }};int main() { fastio; int N; cin&gt;&gt;N; adj_list G(N+1); for (int i=0; i&lt;N-1; i++) { int u, v; cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v); G[v].push_back(u); } LCA lca(G, 1); int M; cin&gt;&gt;M; while (M--) { int u, v; cin&gt;&gt;u&gt;&gt;v; cout&lt;&lt;lca.find(u, v)&lt;&lt;endl; }}[/expand]관련 문제1761트리의 두 노드간의 거리를 구하는 쿼리들을 처리해야 한다.LCA 관련 문제의 가장 기본적인 유형인 것 같다.[expand]summary: 풀이ancestors를 만들 때, 같은 방법으로 2^i번째 조상까지의 거리를 기록해놓는다.탐색시 조상으로 이동할 때마다 거리도 같이 계산해준다.[/expand]13511(u, v)간의 경로의 비용을 처리하는 쿼리와, (u, v)간의 경로 중 k번째 정점을 출력하는 쿼리를 진행해야 한다.[expand]summary: 힌트최단경로가 u -&gt; LCA + LCA -&gt; v라는 점을 잘 생각해서,find의 원리를 잘 생각해보면서 두 가지 쿼리를 각각 짜자.[/expand]15480LCA(u, v)를 구하면 되는데, 쿼리마다 루트가 바뀐다.[expand]summary: 힌트그려놓고 여러 케이스를 생각해보며 관찰을 열심히 해보자. 파이팅!(죄송.. 생각보다 쉽게 찾아짐)[/expand]" } ]
